
"""
S = 2, 15, 5, 1, 5, 10, 31, 20，15
求某一天买入，某天卖出收益最大值
方法一暴力枚举法，利用双重循环，复杂度O(n^2)
方法二分而治之，切割成两部分，前半部分计算后半部分计算, 复杂度O(nlogn)
方法三假设第N天卖出profit=s[n] - Min(s[0:n-1]) 遍历寻找profit最大值，复杂度O(n)
"""


"""
给定一个整数，计算他二进制1的个数
方法一暴力枚举法
count = 0
while(x>0):
   count += 1
   x &= (x-1)
方法二建立一个256个长度的数组，每个下标存储1的个数P
假设一个32位整数x二进制中，由四个字节每个字节八位组成
b0=x&0xff, b1=(x&0xff000000)>>24,b2=(x&0xff0000)>>16,b3=(x&0xff000000)>>24
然后计算p[b0]+p[b1]+p[b2]+p[b3]
"""


"""
整数数组A, 整数M 求是否存储在 M = A[i] + A[j]
1.首选对数组A排序，平均时间复杂度O(nlogn)
2.对有序数组A进行折半查找M-A[i], 时间复杂度O(nlogn)
所以总共O(2nlogn)
"""


"""
假设A="afghenj" B="atfkuhndjop" 查找他们的最大共同子串
最大共同字串用lcs(A, B)表示，
如果A，B 最后一个字符相同则lcs(A, B)=lcs(A(n-1), B(m-1))+an
如果A，B最后一个字符不相同则lcs(A, B)=max(lcs(A, B(m-1)), lcs(A(n-1), B))
"""


"""
给定一个数组，对它进行排序使得满足如下条件
B[0]<=B[1]>=B[2]<=B[3]>=B[4]
第一种方法对B进行降序排列，然后相邻两两交换，时间复杂度O(nlogn)
第二种方法排序后寻找中位数，然后组数组两两组合
第三种方法遍历B如果i为偶数并且B[i]>B[i+1]则交换，如果i为奇数B[i]<B[i+1]则交换
"""


"""
判断第一个字符串是不是第二个字符的倒转 car的倒转可以是arc, rca
给定的字符串收尾相连arcarc,如果car in arcarc则是倒转
"""

"""
给定两个整形变量a, b 交换他们的值，不使用第三方变量
a = a^b; b=a^b; a=a^b  a ^= b ^=a ^= b
x&!(x-1)取最低位1
位交换
def swap(x, i, j):
    if(((x>>i)&1)!=((x>>j)&1)):
        x ^= (1<<i)|(1<<j)
    return x
"""

"""
给定一个集合S,要求打印出集合S的所有子集
给集合位111. 他的子集2*2*2 算法复杂度O(2^n)
"""

"""
给定x,y 求最大公约数 不能用* % > /
欧几里得算法 算法复杂度O(n^2)
def gcd(a, b):
    if(a%b==0):
        return b
    d = a%b
    return gcd(b, d)
"""